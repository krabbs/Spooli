<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Prusa MMU3 Filament‑Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --prusa-orange: #f2801b;
      --bg-light: #f7f7f7;
      --card-bg: #fff;
      --text-dark: #333;
      --text-light: #fff;
    }
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      font-family: 'Open Sans', sans-serif;
      background: var(--bg-light);
      color: var(--text-dark);
    }
    header {
      background: var(--prusa-orange);
      color: var(--text-light);
      padding: 1rem;
      text-align: center;
      font-size: 1.5rem;
      font-weight: 600;
    }
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .top {
      display: flex;
      flex: 1 0 auto;
      gap: 1rem;
      padding: 1rem;
    }
    .card {
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 1rem;
      position: relative;
      overflow: auto;
      flex: 1;
    }
    h2 {
      margin-top: 0;
      color: var(--prusa-orange);
    }
    .shine-overlay {
      position: absolute;
      top: 0; left: -50%;
      width: 50%;
      height: 100%;
      background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
      transform: skewX(-20deg);
      pointer-events: none;
      animation: none;
    }
    .printing .shine-overlay {
      animation: shine-move 2.5s linear infinite;
    }
    @keyframes shine-move {
      0% { left: -50% }
      100% { left: 150% }
    }

    ul#spool-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .spool-item {
      margin: 0.75rem 0;
    }
    .spool-label {
      display: flex;
      justify-content: space-between;
      font-weight: 600;
    }
    .bar-container {
      background: #eee;
      border-radius: 6px;
      height: 14px;
      overflow: hidden;
      margin-top: 0.3rem;
    }
    .bar {
      height: 100%;
      background: var(--prusa-orange);
      transition: width 0.4s ease;
    }
    .editable {
      cursor: pointer;
      border-bottom: 1px dashed var(--prusa-orange);
    }

    #all-spools {
      flex: 0 0 auto;
      padding: 1rem 1rem 0;
      overflow: auto;
    }
    #all-spools table {
      width: 100%;
      border-collapse: collapse;
    }
    #all-spools th, #all-spools td {
      border: 1px solid #ddd;
      padding: 0.5rem;
      text-align: left;
    }
    #all-spools th {
      background: #f0f0f0;
    }
    [contenteditable] {
      -webkit-user-modify: read-write-plaintext-only;
    }
    [contenteditable]:focus {
      outline: 1px solid var(--prusa-orange);
      background-color: #fff8f0;
    }

    #status-bar {
      background: var(--card-bg);
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-around;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      flex: 0 0 auto;
      order: -1;
    }
    #status-bar div {
      font-size: 0.9rem;
    }

    #chart-card.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <header>Prusa MMU3 Filament‑Monitor</header>
  <div id="status-bar">
    <div><strong>MMU Slot:</strong> <span id="st-mmu"></span></div>
    <div><strong>Status:</strong> <span id="st-status"></span></div>
    <div><strong>Fortschritt:</strong> <span id="st-progress"></span></div>
    <div><strong>Job:</strong> <span id="st-job"></span></div>
    <div><strong>Live:</strong> <span id="st-live"></span></div>
  </div>
  <div class="container">
    <div class="top">
      <div id="spool-card" class="card">
        <div class="shine-overlay"></div>
        <h2>Restgewicht aktive Spulen</h2>
        <ul id="spool-list">
          {% if spool_state %}
            {% set max_w = (spool_state.values() | max) or 1 %}
            {% for slot, g in spool_state.items() | sort %}
              <li class="spool-item">
                <div class="spool-label">
                  <span>Slot {{ slot }}</span>
                  <span><span class="editable" data-tool="{{ slot }}">{{ "%.1f"|format(g) }}</span> g</span>
                </div>
                <div class="bar-container">
                  <div class="bar" style="width:{{ ((g / max_w) * 100) | round(1) }}%"></div>
                </div>
              </li>
            {% endfor %}
          {% endif %}
        </ul>
      </div>
      <div id="chart-card" class="card">
        <h2>Aktueller Druckfortschritt</h2>
        <canvas id="liveChart"></canvas>
      </div>
    </div>
    <section id="all-spools">
      <h2>Alle Spulen in DB</h2>
      <table>
        <thead>
          <tr>
            <th>ID</th><th>Name</th><th>Material</th><th>Farbe</th><th>Rest (g)</th><th>Erstverwendung</th><th>Letzte Verwendung</th><th>Slot</th>
          </tr>
        </thead>
        <tbody id="db-list">
          {% for spool in spool_db %}
            <tr data-row-id="{{ spool.id }}">
              <td data-field="id">{{ spool.id }}</td>
              <td contenteditable="true" data-field="name">{{ spool.name }}</td>
              <td contenteditable="true" data-field="material">{{ spool.material }}</td>
              <td contenteditable="true" data-field="color">{{ spool.color }}</td>
              <td contenteditable="true" data-field="remaining_g">{{ "%.1f"|format(spool.data.remaining_g) }}</td>
              <td data-field="first_used">{{ spool.data.first_used or '-' }}</td>
              <td data-field="last_used">{{ spool.data.last_used or '-' }}</td>
              <td data-field="slot">{{ spool.usage.slot if spool.usage.slot is not none else '-' }}</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </section>
  </div>
  <script>
    // Chart initialisieren
    const ctx = document.getElementById('liveChart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [] },
      options: {
        responsive: true,
        animation: false,
        scales: {
          x: { title: { display: true, text: 'Fortschritt %' }, min: 0, max: 100 },
          y: { title: { display: true, text: 'Filament mm' }, beginAtZero: true }
        }
      }
    });

    // Diese Variable speichert das Element, das gerade bearbeitet wird.
    let activeEditElement = null;

    // Update-Funktion für alle Daten
    async function updateData() {
      try {
        // Status aktualisieren
        const st = await fetch('/status').then(r => r.json());
        document.getElementById('st-mmu').textContent = st.tool_mmu;
        document.getElementById('st-status').textContent = st.tool_state;
        document.getElementById('st-progress').textContent = st.tool_progress.toFixed(1) + '%';
        document.getElementById('st-job').textContent = st.tool_job;
        document.getElementById('st-live').textContent = st.tool_live;

        // Aktive Spulen-Gewichte laden (dies wird die serverseitig geladene Liste aktualisieren)
        const weights = await fetch('/spool_weights').then(r => r.json());
        const entries = Object.entries(weights);
        const list = document.getElementById('spool-list');
        list.innerHTML = ''; // Leert die Liste, bevor sie mit neuen Daten gefüllt wird
        const maxW = Math.max(...Object.values(weights).map(v => parseFloat(v) || 0), 1);
        entries.sort((a, b) => a[0] - b[0]); // Sortiert nach Slot-Nummer
        entries.forEach(([t, g]) => {
          const gnum = parseFloat(g) || 0;
          list.innerHTML += `
            <li class="spool-item">
              <div class="spool-label">
                <span>Slot ${t}</span>
                <span><span class="editable" data-tool="${t}">${gnum.toFixed(1)}</span> g</span>
              </div>
              <div class="bar-container">
                <div class="bar" style="width:${((gnum / maxW) * 100).toFixed(1)}%"></div>
              </div>
            </li>`;
        });

        // Chart-Daten aktualisieren
        const data = await fetch('/data').then(r => r.json());
        if (chart.data.datasets.length !== entries.length) {
          chart.data.datasets = entries.map(([t]) => ({
            label: `Slot ${t}`,
            data: [],
            fill: false,
            tension: 0.2
          }));
        }
        chart.data.labels = data.map(p => p[0].toFixed(1));
        chart.data.datasets.forEach((ds, i) => {
          ds.data = data.map(p => p[1][entries[i][0]] || 0);
        });
        chart.update();

        // Intelligente Aktualisierung der Haupt-Spulentabelle
        const db_spools = await fetch('/spools').then(r => r.json());
        const tbody = document.getElementById('db-list');
        const server_ids = new Set();

        db_spools.forEach(spool => {
          const spoolId = spool.id;
          server_ids.add(String(spoolId));
          let row = tbody.querySelector(`tr[data-row-id="${spoolId}"]`);

          const spoolData = {
            id: spool.id,
            name: spool.name,
            material: spool.material,
            color: spool.color,
            remaining_g: spool.data.remaining_g.toFixed(1),
            first_used: spool.data.first_used || '-',
            last_used: spool.data.last_used || '-',
            slot: spool.usage.slot != null ? spool.usage.slot : '-'
          };

          if (!row) {
            // Zeile existiert nicht -> neu erstellen und anhängen
            row = document.createElement('tr');
            row.dataset.rowId = spoolId;
            row.innerHTML = `
              <td data-field="id">${spoolData.id}</td>
              <td contenteditable="true" data-field="name">${spoolData.name}</td>
              <td contenteditable="true" data-field="material">${spoolData.material}</td>
              <td contenteditable="true" data-field="color">${spoolData.color}</td>
              <td contenteditable="true" data-field="remaining_g">${spoolData.remaining_g}</td>
              <td data-field="first_used">${spoolData.first_used}</td>
              <td data-field="last_used">${spoolData.last_used}</td>
              <td data-field="slot">${spoolData.slot}</td>`;
            tbody.appendChild(row);
          } else {
            // Zeile existiert -> Zellen nur bei Bedarf aktualisieren
            row.querySelectorAll('td[data-field]').forEach(cell => {
              const field = cell.dataset.field;
              const newValue = String(spoolData[field]);
              if (cell !== activeEditElement && cell.textContent !== newValue) {
                cell.textContent = newValue;
              }
            });
          }
        });

        // Alte Zeilen entfernen, die nicht mehr vom Server kommen
        tbody.querySelectorAll('tr[data-row-id]').forEach(row => {
          if (!server_ids.has(row.dataset.rowId)) {
            row.remove();
          }
        });

      } catch (error) {
        console.error("Fehler beim Aktualisieren der Daten:", error);
      }
    }

    // Event Listeners für das Bearbeiten der Tabelle
    const dbList = document.getElementById('db-list');

    dbList.addEventListener('focusin', e => {
      if (e.target.matches('[contenteditable]')) {
        activeEditElement = e.target;
      }
    });

    dbList.addEventListener('focusout', e => {
      if (e.target.matches('[contenteditable]')) {
        activeEditElement = null;
        const id = e.target.closest('tr').dataset.rowId;
        const field = e.target.dataset.field;
        const value = e.target.textContent;
        fetch(`/update_spool/${id}/${field}/${encodeURIComponent(value)}`, { method: 'POST' })
          .then(response => {
            if (response.ok) {
              console.log('Gespeichert:', field, '=', value);
            } else {
              console.error('Fehler beim Speichern.');
            }
          });
      }
    });
    
    // Initialer Aufruf beim Laden der Seite
    updateData();

    // Regelmäßige Aktualisierung alle 2 Sekunden
    setInterval(updateData, 2000);
  </script>
</body>
</html>
